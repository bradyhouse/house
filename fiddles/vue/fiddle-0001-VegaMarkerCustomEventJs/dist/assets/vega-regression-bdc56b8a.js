import{A as R,F as D,x as N,z,B as F,y as I,D as L,E as U,C as j}from"./vega-statistics-100b599b.js";import{i as x,T as b}from"./vega-dataflow-7e3fa937.js";import{u as k,c as f,r as T,k as M,l as A}from"./vega-util-7f144c9d.js";function C(e,r){var a=[],c=function(m){return m(s)},d,o,t,s,i,n;if(r==null)a.push(e);else for(d={},o=0,t=e.length;o<t;++o)s=e[o],i=r.map(c),n=d[i],n||(d[i]=n=[],n.dims=i,a.push(n)),n.push(s);return a}function O(e){b.call(this,null,e)}O.Definition={type:"Loess",metadata:{generates:!0},params:[{name:"x",type:"field",required:!0},{name:"y",type:"field",required:!0},{name:"groupby",type:"field",array:!0},{name:"bandwidth",type:"number",default:.3},{name:"as",type:"string",array:!0}]};k(O,b,{transform(e,r){const a=r.fork(r.NO_SOURCE|r.NO_FIELDS);if(!this.value||r.changed()||e.modified()){const c=r.materialize(r.SOURCE).source,d=C(c,e.groupby),o=(e.groupby||[]).map(f),t=o.length,s=e.as||[f(e.x),f(e.y)],i=[];d.forEach(n=>{R(n,e.x,e.y,e.bandwidth||.3).forEach(m=>{const l={};for(let u=0;u<t;++u)l[o[u]]=n.dims[u];l[s[0]]=m[0],l[s[1]]=m[1],i.push(x(l))})}),this.value&&(a.rem=this.value),this.value=a.add=a.source=i}return a}});const E={constant:N,linear:z,log:F,exp:I,pow:L,quad:U,poly:j},B=(e,r)=>e==="poly"?r:e==="quad"?2:1;function S(e){b.call(this,null,e)}S.Definition={type:"Regression",metadata:{generates:!0},params:[{name:"x",type:"field",required:!0},{name:"y",type:"field",required:!0},{name:"groupby",type:"field",array:!0},{name:"method",type:"string",default:"linear",values:Object.keys(E)},{name:"order",type:"number",default:3},{name:"extent",type:"number",array:!0,length:2},{name:"params",type:"boolean",default:!1},{name:"as",type:"string",array:!0}]};k(S,b,{transform(e,r){const a=r.fork(r.NO_SOURCE|r.NO_FIELDS);if(!this.value||r.changed()||e.modified()){const c=r.materialize(r.SOURCE).source,d=C(c,e.groupby),o=(e.groupby||[]).map(f),t=e.method||"linear",s=e.order==null?3:e.order,i=B(t,s),n=e.as||[f(e.x),f(e.y)],m=E[t],l=[];let u=e.extent;T(E,t)||M("Invalid regression method: "+t),u!=null&&t==="log"&&u[0]<=0&&(r.dataflow.warn("Ignoring extent with values <= 0 for log regression."),u=null),d.forEach(p=>{if(p.length<=i){r.dataflow.warn("Skipping regression with more parameters than data points.");return}const y=m(p,e.x,e.y,s);if(e.params){l.push(x({keys:p.dims,coef:y.coef,rSquared:y.rSquared}));return}const w=u||A(p,e.x),q=h=>{const g={};for(let v=0;v<o.length;++v)g[o[v]]=p.dims[v];g[n[0]]=h[0],g[n[1]]=h[1],l.push(x(g))};t==="linear"||t==="constant"?w.forEach(h=>q([h,y.predict(h)])):D(y.predict,w,25,200).forEach(q)}),this.value&&(a.rem=this.value),this.value=a.add=a.source=l}return a}});const J=Object.freeze(Object.defineProperty({__proto__:null,loess:O,regression:S},Symbol.toStringTag,{value:"Module"}));export{J as r};
